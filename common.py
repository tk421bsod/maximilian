#common.py: a shared library containing a bunch of useful stuff
import logging
import subprocess
import os
import time

class Version:
    def __init__(self):
        self.major = 0
        self.minor = 0
        self.patch = 0

class token:
    def get(self, filename):
        self.logger = logging.getLogger(name=f'maximilian.{__name__}')
        self.logger.info(f"Getting token from {filename}.")
        try:
            with open(filename, "r") as tokenfile:
                return tokenfile.readline()
        except:
            print("Couldn't find a file containing a token. It needs to be named either 'token.txt' (stable), 'betatoken.txt' (beta), or 'devtoken.txt' (dev).")

def load_config():
    '''Loads configuration data from the config file generated by setup.sh.'''
    config = {}
    #Uncomment the following line to suppress KeyErrors that can happen when trying to access config. This may break stuff.
    #import collections; config = collections.defaultdict(lambda: None)
    with open('config', 'r') as configfile:
        for i in configfile.readlines():
            if not i.strip().startswith('#') and i.strip():
                i = i.strip().split(':',1)
                config[i[0]] = i[1]
    return config

def convert_list(arg):
    '''
    Turns lists with only one element into just that element. Lists with more than one element stay the same.

    Example:
        convert_list([1]) -> 1
        convert_list([1, 2, 3]) -> [1, 2, 3]
    '''
    return arg[0] if len(arg) == 1 else arg

def list_in_str(list, string):
    '''
    Tests if any elements in 'list' are in 'string'.

    Returns:
        True - An element in 'list' is in 'string'.
        False - No elements in 'list' are in 'string'.
    '''
    for elem in list:
        if elem in string:
            return True
    return False

def run_command(args):
    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    return {"output":convert_list(out.decode('utf-8').strip().split("\n")), "returncode":p.returncode}

def get_latest_commit():
    try:
        return run_command(['git', 'rev-parse', '--short', 'HEAD'])['output']
    except Exception:
        pass

def update():
    '''
    Python implementation of the setup.sh updater.
    This method must be called *outside* of any async context due to its blocking input and subprocess.run calls.
    '''
    #no logger yet :(
    print("initializing updater\n")
    initial = get_latest_commit()
    #get current remote
    remote = run_command(['git', 'remote'])['output'][0]
    #get current branch
    branch = run_command(['git', 'branch', '--show-current'])['output']
    time.sleep(0.5)
    print(f"You're currently on the '{branch}' branch.")
    if branch != 'release':
        print("Warning: updates on this branch may be unstable.")
        print("You can switch back to the 'release' branch at any time using 'git checkout release'.")
    else:
        print("You can switch to other branches at any time using 'git checkout <branch>'.")
        print("Use 'git branch' to view a list of branches.")
    time.sleep(0.5)
    print("Checking for updates...")
    try:
        subprocess.run(['git', 'fetch', remote], check=True)
    except subprocess.CalledProcessError:
        print("Something went wrong while checking for updates.")
        return
    after = run_command(['git', 'rev-parse', '--short', f'{remote}/{branch}'])
    if initial != after:
        resp = input("Update available. Would you like to apply it? Y/N\n").lower().strip()
        if resp == "y":
            print("\nApplying update...")
            pull = run_command(['git', 'pull'])
            output = "\n".join([i for i in pull['output']])
            print("\nGit output:")
            print(output)
            if pull['returncode']:
                print("Something went wrong while applying the update. Take a look at the above output for details.")
                os._exit(124)
            print("Update applied.")
            if list_in_str(['main.py', 'common.py', 'db.py', 'settings.py'], output):
                print("This update changed some important files. Run main.py again.")
                os._exit(111)
        else:
            print("\nNot applying the update.")
    else:
        print("No updates available.")
    time.sleep(1)
